<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Workbook for Rust &amp; Qt workshop</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Rust and Qt</a></li><li class="chapter-item expanded "><a href="preparations.html"><strong aria-hidden="true">1.</strong> Preparations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setup.html"><strong aria-hidden="true">1.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="tooling-check.html"><strong aria-hidden="true">1.2.</strong> Tooling check</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Tutorial</li><li class="chapter-item expanded "><a href="tutorial/index.html"><strong aria-hidden="true">2.</strong> Idea</a></li><li class="chapter-item expanded "><a href="tutorial/cli.html"><strong aria-hidden="true">3.</strong> CLI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/cli/hello-world.html"><strong aria-hidden="true">3.1.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="tutorial/cli/image-filters.html"><strong aria-hidden="true">3.2.</strong> Image filter CLI application</a></li><li class="chapter-item expanded "><a href="tutorial/cli/final-code.html"><strong aria-hidden="true">3.3.</strong> Final application</a></li></ol></li><li class="chapter-item expanded "><a href="tutorial/library.html"><strong aria-hidden="true">4.</strong> Implementing a library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/library/recreate-as-workspace.html"><strong aria-hidden="true">4.1.</strong> Recreate the project as a workspace</a></li><li class="chapter-item expanded "><a href="tutorial/library/create-library.html"><strong aria-hidden="true">4.2.</strong> Creating the library</a></li><li class="chapter-item expanded "><a href="tutorial/library/cli-with-library.html"><strong aria-hidden="true">4.3.</strong> Using the library in your CLI binary</a></li></ol></li><li class="chapter-item expanded "><a href="tutorial/qt-gui/index.html"><strong aria-hidden="true">5.</strong> Qt GUI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/qt-gui/build-setup.html"><strong aria-hidden="true">5.1.</strong> Setting up the build system</a></li><li class="chapter-item expanded "><a href="tutorial/qt-gui/creating-the-gui.html"><strong aria-hidden="true">5.2.</strong> Creating the QML GUI</a></li><li class="chapter-item expanded "><a href="tutorial/qt-gui/qquickpainteditem.html"><strong aria-hidden="true">5.3.</strong> QQuickPaintedItem in Rust</a></li><li class="chapter-item expanded "><a href="tutorial/qt-gui/rust-implementation.html"><strong aria-hidden="true">5.4.</strong> Adding behavior in Rust</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">6.</strong> References</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Workbook for Rust &amp; Qt workshop</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ferrous-systems/qt-training-2023" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust--qt-workshop"><a class="header" href="#rust--qt-workshop">Rust &amp; Qt workshop</a></h1>
<p>This workbook contains the material for a Rust &amp; Qt workshop held by <a href="https://ferrous-systems.com/">Ferrous Systems</a>, developed and held together with <a href="https://kdab.com">KDAB</a>. It is based on work by <a href="https://fnordig.de/">Jan-Erik Rediger</a>.</p>
<p>It is split into 2 parts:</p>
<h2 id="part-1-setup"><a class="header" href="#part-1-setup">Part 1: <a href="preparations.html">Setup</a></a></h2>
<p>An installation guide for all tooling used throughout this book.</p>
<h2 id="part-2-tutorial"><a class="header" href="#part-2-tutorial">Part 2: <a href="./tutorial/index.html">Tutorial</a></a></h2>
<p>A hands-on tutorial writing Rust and compiling it in 3 variations: as a command-line app, as a library and as a small Qt app using the library using CXX-Qt.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="preparations"><a class="header" href="#preparations">Preparations</a></h1>
<p>This chapter contains information about the course material and an installation guide.</p>
<h2 id="workshop-materials"><a class="header" href="#workshop-materials">Workshop Materials</a></h2>
<p>Clone the <a href="https://github.com/ferrous-systems/qt-training-2023">workshop git repository</a>:</p>
<pre><code>git clone https://github.com/ferrous-systems/qt-training-2023
</code></pre>
<p>The workshop repository contains all workshop materials, e.g. code examples,
and the source for this workbook.</p>
<h2 id="required-software"><a class="header" href="#required-software">Required Software</a></h2>
<p>The <a href="./setup.html">Setup guide</a> helps you install the required software used throughout this book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<p>This section describes how to set up the toolchain
for compiling Rust programs to WebAssembly
and integrate them with the different environments we will look at.</p>
<h2 id="the-rust-toolchain"><a class="header" href="#the-rust-toolchain">The Rust Toolchain</a></h2>
<p>You will need the standard Rust toolchain, including <code>rustup</code>, <code>rustc</code>, and
<code>cargo</code>.</p>
<p><a href="https://www.rust-lang.org/tools/install">Follow these instructions to install the Rust toolchain.</a></p>
<p>This will install the Rust toolchain and the targets for the host platform.
Windows users need to choose between the <code>msvc</code> and <code>mingw</code> targets.
We recommend the <code>msvc</code> target, unless you already have <code>mingw</code> installed.</p>
<p>The course will only use the stable compiler, we don't require any experimental feature flags.
The latest Rust should work best, though older versions have no known issues.</p>
<h2 id="additional-tooling"><a class="header" href="#additional-tooling">Additional tooling</a></h2>
<p>For those interested in following the Qt section of the course,
installation of Qt is needed.</p>
<p>The provided examples use Qt 6 and are tested against Qt 6.5 LTS.
If you can only install Qt 5, you will need to modify the QML code,
as the FileDialog API has changed between Qt 5 and 6.
Apart from that, The Rust-Qt integration (<a href="https://github.com/KDAB/cxx-qt">CXX-Qt</a>)
should work the same with Qt 5 and Qt 6.</p>
<p>How to install Qt depends a lot on the platform you're using.
Many platforms even have multiple options on how to install Qt.
The main goal is to ensure that <code>qmake</code> for Qt 6 is in your <code>PATH</code>.</p>
<p>You can check this by using <code>qmake --version</code>, which should return something like this:</p>
<pre><code class="language-console">$ qmake --version
QMake version 3.1
Using Qt version 6.5.1 in /usr/lib64
</code></pre>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<p>Many distributions have Qt already packaged, if your package manager doesn't offer development versions of Qt, you can always fall back to using the <a href="https://doc.qt.io/qt-6/get-and-install-qt.html">Qt online installer</a>.</p>
<p>No matter which installation method you choose, make sure to install the QML (aka. QtQuick/Declarative) and Network modules, as well as any packages needed for QtQuickControls2.</p>
<p>On Fedora for a full installation of Qt, use:</p>
<pre><code class="language-bash">$ dnf install &quot;qt6-*-devel&quot;
</code></pre>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>We have had the best experience with installing Qt on Windows using the <a href="https://doc.qt.io/qt-6/get-and-install-qt.html">Qt online installer</a>.
Make sure to select and install a version of Qt 6.</p>
<p>Then add the installation directory to your <code>PATH</code> environment variable and make sure <code>qmake</code> is in your <code>PATH</code> by running <code>qmake --version</code>.
You may have to restart your terminal for this to work correctly.</p>
<h3 id="macos"><a class="header" href="#macos">MacOS</a></h3>
<p>Preferrably install Qt using the <a href="https://doc.qt.io/qt-6/get-and-install-qt.html">Qt online installer</a>.
Make sure to select and install a version of Qt 6.</p>
<p>You can also try installing Qt using homebrew.</p>
<pre><code class="language-zsh">$ brew install qt6
</code></pre>
<p>In any case, make sure the installation directory is added to your path and qmake can be found by your command line using <code>qmake --version</code>.
You may have to restart your terminal for this to work correctly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tooling-check"><a class="header" href="#tooling-check">Tooling check</a></h1>
<h2 id="setup-check"><a class="header" href="#setup-check">Setup check</a></h2>
<p>✅ Fully restart your terminal (not just open a fresh tab).</p>
<p>✅ Let's check that you have installed Rust.</p>
<pre><code class="language-console">$ rustc --version
rustc 1.73.0 (cc66ad468 2023-10-03)
</code></pre>
<pre><code class="language-console">$ cargo --version
cargo 1.73.0 (9c4383fb5 2023-08-26)
</code></pre>
<p>✅ In a work directory, run:</p>
<pre><code class="language-console">$ cargo new --bin hello-world
$ cd hello-world
$ cargo run --release
   Compiling hello-world v0.1.0 (C:\Code\ferrous\hello-world)
    Finished release [optimized] target(s) in 0.99s
     Running `target\release\hello-world.exe`
Hello, world!
</code></pre>
<p>This ensures that the whole toolchain works correctly and finds the system linker. This should work at all times, if it doesn't, immediately ask for a trainer.</p>
<h1 id="qt-specifics"><a class="header" href="#qt-specifics">Qt specifics</a></h1>
<p>For those interested in following the Qt section of the course,
the Rust toolchain must be able to find the Qt installation.</p>
<p>The Rust-Qt bindings (<a href="https://github.com/kdab/cxx-qt">CXX-Qt</a>) need to be able to find your Qt installation.
For this it relies on the <code>qmake</code> executable.
CXX-Qt will try to find qmake in your path.</p>
<p>✅ Confirm that qmake reports a version of Qt 6</p>
<pre><code class="language-console">$ qmake --version
QMake version 3.1
Using Qt version 6.5.1 in /usr/lib64
</code></pre>
<blockquote>
<p>If for some reason you do not want to add <code>qmake</code> to your path, you can use the <code>QMAKE</code> environment variable
to tell CXX-Qt where to find the Qt6 qmake executable.
e.g.:</p>
<pre><code class="language-console">QMAKE=/usr/bin/qmake6 cargo run
</code></pre>
</blockquote>
<h2 id="hello-world-with-qt"><a class="header" href="#hello-world-with-qt">Hello world with Qt</a></h2>
<p>To test that the Rust toolchain can indeed find and link to your Qt installation, you can clone the training
repository and run the <code>qt-hello-world</code> example crate.</p>
<p><strong>✅ Clone the repository</strong></p>
<pre><code class="language-console">$ git clone https://github.com/ferrous-systems/qt-training-2023
</code></pre>
<p><strong>✅ Navigate to the qt-hello-world crate</strong></p>
<pre><code class="language-console">$ cd qt-training-2023/crates/qt-hello-world/
</code></pre>
<p><strong>✅ Test that it works</strong></p>
<pre><code class="language-console">$ cargo run
</code></pre>
<p>If you don't have <code>qmake</code> in your PATH, use:</p>
<pre><code class="language-console">$ QMAKE=/path/to/your/qmake cargo run
</code></pre>
<p>The resulting application should look like this:</p>
<p><img src="./resources/qt-hello-world.png" alt="A Qt Application saying &quot;Hello World&quot;" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="idea"><a class="header" href="#idea">Idea</a></h1>
<p>We now want to build a slightly more complex application.</p>
<p>The idea is to use an existing image manipulation library
to apply filters to a given image<sup class="footnote-reference"><a href="#1">1</a></sup>.
This example will show us how to use an existing Rust crate,
how to handle input and output and how to interact with the different environments.</p>
<p>We start off with building a command-line tool run using <code>wasmtime</code>,
then build a web application running completely client-side,
and last as an edge computing API that processes images posted to it.</p>
<p>We will work with the following example image (but really any image will work).
Right-click it and save it to disk for later use.</p>
<p><img src="tutorial/kongelige-slott.jpg" alt="" /></p>
<p>When applying the filter named &quot;1977&quot;, this is the result:</p>
<p><img src="tutorial/kongelige-slott-1977.png" alt="" /></p>
<p>Several more filters are available in the library.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>The image filters are inspired by Instagram. The implementation is based on <a href="https://github.com/una/CSSgram">CSSgram</a>, which was ported to Rust by <a href="https://github.com/ha-shine">@ha-shine</a>. The example image was taken on 2022-10-28 by Jan-Erik Rediger.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-interface"><a class="header" href="#command-line-interface">Command-line interface</a></h1>
<p>In this tutorial you'll get familiar with:</p>
<ul>
<li>Building Rust code for your local target</li>
<li>Running applications on the command-line</li>
<li>Parsing command line parameters by hand</li>
<li>Re-using existing crates in your application</li>
<li>Rust type systems basics</li>
</ul>
<p>We start with a command-line tool that takes an image and a filter name as input.
It applies the given filter to the image and produces an <code>output.png</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world-on-the-command-line"><a class="header" href="#hello-world-on-the-command-line">Hello World on the command line</a></h1>
<p>✅ Create a new Rust project</p>
<pre><code>cargo new rustagram
cd rustagram
</code></pre>
<p>✅ To start the tool will only print a message. Open <code>src/main.rs</code> and add</p>
<pre><code class="language-rust">fn main() {
    println!(&quot;Hello World from wasmtime!&quot;);
}</code></pre>
<p>Next, <a href="tutorial/cli/image-filters.html">start integrating image filters</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="image-filter-application"><a class="header" href="#image-filter-application">Image filter application</a></h1>
<p>Now that you can build and run an application compiled to WebAssembly,
it's time to build some functionality into it.</p>
<p>The goal is:</p>
<ul>
<li>Take an input file, a filter name and, optionally, an output file (or &quot;output.jpg&quot; as the default).</li>
<li>Load the input file, apply the given filter to this image, then write the resulting image to the output file.</li>
</ul>
<p>You can continue with the previously created project.</p>
<p>✅ Open <code>src/main.rs</code> again and replace the <code>println!</code> line with code to parse the arguments.</p>
<pre><code class="language-rust">fn main() {
    let mut args = std::env::args().skip(1);
    let input = args.next().expect(&quot;INPUT required&quot;);
    let filter = args.next().expect(&quot;FILTER required&quot;);
    let output = args.next().unwrap_or_else(|| &quot;output.jpg&quot;.to_string());

    dbg!((input, filter, output));
}</code></pre>
<p>✅ Build and run this to make sure it works as expected.</p>
<p>✅ Now add a dependency to handle image manipulation. The image filters are readily available in the <a href="https://crates.io/crates/rustagram2"><code>rustagram2</code></a> crate.
Add the <code>rustagram2</code> crate as a dependency in <code>rustagram/Cargo.toml</code></p>
<pre><code class="language-toml">[dependencies]
rustagram2 = &quot;2.0.0&quot;
</code></pre>
<p>The documentation is available on <a href="https://docs.rs/rustagram2/2.0.0/rustagram/">docs.rs/rustagram2</a>.</p>
<p>✅ You need a <a href="https://docs.rs/rustagram2/2.0.0/rustagram/enum.FilterType.html"><code>FilterType</code></a> to apply later.
<code>rustagram2</code> shows the available filters <a href="https://docs.rs/rustagram2/2.0.0/rustagram/enum.FilterType.html">in the <code>FilterType</code> documentation</a>.
It also has <a href="https://doc.rust-lang.org/nightly/core/str/trait.FromStr.html"><code>FromStr</code></a> from the standard library implemented for it, so you can parse strings into the filter type by calling <code>parse()</code> on the string.</p>
<pre><code class="language-rust">let filter_type = filter.parse().expect(&quot;can't parse filter name&quot;);</code></pre>
<p>An unknown filter name would cause an error.
For now you don't need to handle that.
Your application can just panic and exit.</p>
<p>If you compile everything at this point you will probably hit a type annotation error.
You can try to resolve that now.
You can also continue and observe how this error will be resolved once you add more code in the next steps.</p>
<p>Now comes the main part of the application: load the image, apply the filter and save the resulting file.
This is a small challenge for you to write, but the next steps guide you through it.</p>
<p>✅ You need to read the file from disk and turn it into an object you can work with.
<a href="https://docs.rs/image/0.24.4/image/fn.open.html"><code>image::open</code></a> does that for you easily.
Don't worry about error handling and just <code>unwrap</code>.</p>
<p>✅ The image type you get is able to represent a wide variety of image types.
For this tutorial you want an <a href="https://docs.rs/image/0.24.4/image/type.RgbaImage.html"><code>RgbaImage</code></a>. You can convert your image using the <a href="https://docs.rs/image/0.24.4/image/enum.DynamicImage.html#method.to_rgba8"><code>to_rgba8</code></a> method.</p>
<p>✅ Last but not least you need to apply the selected filter on this image.
The <code>rustagram2</code> crate implements that as the <a href="https://docs.rs/rustagram2/2.0.0/rustagram/trait.RustagramFilter.html#tymethod.apply_filter"><code>apply_filter</code></a> method on a trait.
This trait is automatically implemented for the <code>RgbaImage</code> type you got from <code>to_rgba8</code>.</p>
<p>✅ Save back to the file <code>output</code> by using the <a href="https://docs.rs/image/latest/image/enum.DynamicImage.html#method.save"><code>save</code></a> method available on the image.</p>
<p>With the help of the documentation this should be achievable in a couple of lines of code.</p>
<p>Try it for yourself!</p>
<p>✅ Once you wrote the code, build it again and try to run it.</p>
<p>Expected output when you don't pass any arguments:</p>
<pre><code class="language-console">$ cargo run
thread 'main' panicked at src\main.rs:5:29:
INPUT required
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Expected output when you pass a non-existing file path and a filter name:</p>
<pre><code class="language-console">$ cargo run -- missing-image.jpg 1977
    Finished dev [unoptimized + debuginfo] target(s) in 0.09s
     Running `target\debug\rustagram.exe kongelige-slott.jpg 1977`
thread 'main' panicked at src\main.rs:10:34:
called `Result::unwrap()` on an `Err` value: IoError(Os { code: 2, kind: NotFound, message: &quot;The system cannot find the file specified.&quot; })
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Expected output when you pass the file actually exists.</p>
<pre><code class="language-console">$ cargo run -- kongelige-slott.jpg 1977
    Finished dev [unoptimized + debuginfo] target(s) in 0.09s
     Running `target\debug\rustagram.exe kongelige-slott.jpg 1977`
</code></pre>
<p>The result should then be stored in <code>output.jpg</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="final-application"><a class="header" href="#final-application">Final application</a></h1>
<p>You should have this file tree layout:</p>
<pre><code class="language-console">$ tree
.
├── Cargo.lock
├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<p>To recap your final code should look something like this:</p>
<pre><code class="language-rust">use rustagram::{image, RustagramFilter};

fn main() {
    let mut args = std::env::args().skip(1);
    let input = args.next().expect(&quot;INPUT required&quot;);
    let filter = args.next().expect(&quot;FILTER required&quot;);
    let output = args.next().unwrap_or_else(|| &quot;output.jpg&quot;.to_string());

    let filter_type = filter.parse().expect(&quot;can't parse filter name&quot;);
    let img = image::open(input).unwrap();
    let out = img.to_rgba8().apply_filter(filter_type);
    out.save(output).unwrap();
}</code></pre>
<p>You can build your code like this:</p>
<pre><code>cargo build
</code></pre>
<p>And run it using cargo:</p>
<pre><code>cargo run
</code></pre>
<p>For an optimized build use:</p>
<pre><code>cargo build --release
</code></pre>
<pre><code>cargo run --release
</code></pre>
<hr />
<p>Some ideas on what to do next:</p>
<ul>
<li>Run the application natively: <code>cargo run</code>. Any complications or differences?</li>
<li>Heard of WebAssembly? You can actually run this in WebAssembly - see our <a href="https://github.com/ferrous-systems/wasm-training-2022">WASM Training</a></li>
<li>Try a full command line parser crate - see <a href="https://blessed.rs/crates#section-cli-tools-subsection-argument-parsing">blessed.rs for suggestions</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="library"><a class="header" href="#library">Library</a></h1>
<p>In this tutorial you'll get familiar with:</p>
<ul>
<li>Refactoring your Rust project into multiple libraries (crates)</li>
<li>Running applications on the command-line</li>
<li>Parsing command line paramenters by hand</li>
<li>Re-using existing crates in your application</li>
<li>Learn about borrowing</li>
</ul>
<p>We start with a command-line tool that takes an image and a filter name as input.
It applies the given filter to the image and produces an <code>output.png</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recreate-the-project-as-workspace"><a class="header" href="#recreate-the-project-as-workspace">Recreate the project as workspace</a></h1>
<p>Let's get started by creating a so-called &quot;cargo workspace&quot;. In
a growing project, this is a common refactoring, however, given
the simplicity of our CLI app, it's easier to just start from
the beginning again.</p>
<p>✅ Create yourself an working directory</p>
<pre><code class="language-console">$ mkdir image-workspace
$ cd image-workspace
</code></pre>
<p>✅ create a library crate for image manipulation</p>
<pre><code class="language-console">$ cargo new --lib image-manipulation
</code></pre>
<p>✅ create a binary crate for the CLI app</p>
<pre><code class="language-console">$ cargo new --bin cli
</code></pre>
<p>You folder structure should currently look like this:</p>
<pre><code class="language-console">$ tree
.
└── cli
└── image-manipulation
</code></pre>
<p>✅ create a file called <code>Cargo.toml</code> in the main folder:</p>
<pre><code class="language-console">$ tree
.
└── Cargo.toml
└── cli
└── image-manipulation
</code></pre>
<p>✅ fill that file with the following info:</p>
<pre><code class="language-toml">[workspace]
members = [&quot;cli&quot;, &quot;image-manipulation&quot;]
resolver = &quot;2&quot;
</code></pre>
<p>✅ build the whole workspace once to check everything works</p>
<pre><code class="language-console">$ cargo build
</code></pre>
<p>Move on to <a href="tutorial/library/create-library">creating the library</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-library"><a class="header" href="#creating-a-library">Creating a library</a></h1>
<p>In this section of the tutorial, you will create
a library to handle image manipulation. This library
will have exactly one function. It should:</p>
<ul>
<li>Take a field of bytes representing an image</li>
<li>Take a filter type</li>
</ul>
<p>It should not:</p>
<ul>
<li>Handle any I/O</li>
<li>Do input parsing (like filter name detection, etc.)</li>
</ul>
<p>✅ In <code>image-manipulation/Cargo.toml</code>, add:</p>
<pre><code class="language-toml">[dependencies]
rustagram2 = &quot;2&quot;
log = &quot;0.4&quot;
</code></pre>
<p>We use the <code>log</code> crate to get some visibility into what is happening.</p>
<p>✅ In <code>image-manipulation/src/lib.rs</code>, add the following imports and function headers</p>
<pre><code class="language-rust">use std::io::Cursor;

use rustagram::image::io::Reader;
use rustagram::image::ImageOutputFormat;
use rustagram::{RustagramFilter, FilterType};

pub fn apply_filter(img: &amp;[u8], filter: FilterType) -&gt; Vec&lt;u8&gt; {
    log::debug!(&quot;image: {} bytes, filter: {:?}&quot;, img.len(), filter);
}</code></pre>
<p>This communicates three interesting things:</p>
<ul>
<li>The function is marked <code>pub</code> - this makes it a public function, callable from other libraries. The default in Rust is always private.</li>
<li>The data of the image is an immutable reference to binary data owned outside of the function</li>
<li>The result is a binary vector, but passed out owned - so it cannot be the initial data</li>
</ul>
<h2 id="reading-the-image"><a class="header" href="#reading-the-image">Reading the image</a></h2>
<p>Looking at the signature of <a href="https://docs.rs/image/0.24.3/image/io/struct.Reader.html">Reader</a>, we find that it can only be construted using types that implement the <code>Read</code> trait. <code>&amp;[u8]</code> does not implement the <code>Read</code> trait. However, we can use the
standard libraries <a href="https://doc.rust-lang.org/std/io/struct.Cursor.html">Cursor</a> type
to fix that.</p>
<p>✅ Read the image by inserting the following code</p>
<pre><code class="language-rust">let read_cursor = Cursor::new(img);
let img = Reader::new(cursor)
    .with_guessed_format()
    .unwrap()
    .decode()
    .unwrap();</code></pre>
<p>Now we got the image read and know it works.</p>
<p>✅ Apply the filter</p>
<pre><code class="language-rust">let out = img.to_rgba8().apply_filter(filter);</code></pre>
<p>On the output side, things are the same, but a little bit more complex.
We need to create the output vector. For writing to it, we can again create
a <code>Cursor</code> around it, but this time, we'll do it by <em>mutably borrowing</em> the
<code>Cursor</code>. We can then write to it like to any other IO type.</p>
<p>✅ Write to an output buffer</p>
<pre><code class="language-rust">let mut bytes: Vec&lt;u8&gt; = Vec::new();
let mut write_cursor = Cursor::new(&amp;mut bytes);
out.write_to(&amp;mut write_cursor, ImageOutputFormat::Png)
    .unwrap();

bytes</code></pre>
<p>The last statement - a bare <code>bytes</code> - uses Rusts expression-based nature to mark
<code>bytes</code> as the variable to be returned. If you feel more comfortable, you may use
<code>return bytes</code>.</p>
<p>The final code of the library should now read:</p>
<pre><code class="language-rust">use std::io::Cursor;

use rustagram::image::io::Reader;
use rustagram::image::ImageOutputFormat;
use rustagram::{RustagramFilter, FilterType};

pub fn apply_filter(img: &amp;[u8], filter: FilterType) -&gt; Vec&lt;u8&gt; {
    log::debug!(&quot;image: {} bytes, filter: {:?}&quot;, img.len(), filter);

    let read_cursor = Cursor::new(img);
    let img = Reader::new(cursor)
        .with_guessed_format()
        .unwrap()
        .decode()
        .unwrap();

    let out = img.to_rgba8().apply_filter(filter);
    
    let mut bytes: Vec&lt;u8&gt; = Vec::new();
    let mut write_cursor = Cursor::new(&amp;mut bytes);
    out.write_to(&amp;mut write_cursor, ImageOutputFormat::Png)
        .unwrap();

    bytes
}</code></pre>
<p>Now that we have a library <a href="tutorial/library/cli-with-library.html">let's use it in our CLI</a></p>
<hr />
<p>Some ideas on what to do next:</p>
<ul>
<li>Create further utility functions</li>
<li>Extend the signature and return a <code>Result</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-cli-using-the-library"><a class="header" href="#creating-a-cli-using-the-library">Creating a CLI using the library</a></h1>
<p>Let's now use the library we created in our small CLI app.</p>
<p>✅ In <code>cli/Cargo.toml</code>, add:</p>
<pre><code class="language-toml">[dependencies]
rustagram2 = &quot;2&quot;

[dependencies.image-manipulation]
path = &quot;../image-manipulation&quot;
</code></pre>
<p>✅ Recreate parts of the main function:</p>
<pre><code class="language-rust">use image_manipulation::apply_filter;
use rustagram::FilterType;

fn main() {
    let mut args = std::env::args().skip(1);
    let input = args.next().expect(&quot;INPUT required&quot;);
    let filter = args.next().expect(&quot;FILTER required&quot;);
    let output = args.next().unwrap_or_else(|| &quot;output.jpg&quot;.to_string());

    let filter_type: FilterType = filter.parse().expect(&quot;can't parse filter name&quot;);
}</code></pre>
<p>As our image manipulation library does not handle IO, we will reach for the <code>std::fs::{read,write}</code> function.</p>
<p>✅ Read the image as input</p>
<pre><code class="language-rust">let bytes: Vec&lt;u8&gt; = std::fs::read(input).unwrap();</code></pre>
<p>The type annotation here isn't strictly necessary and is generally omitted, but helps during explaining the example.</p>
<p>✅ Call the <code>apply_filter</code> library function</p>
<pre><code class="language-rust">let manipulated_image = apply_filter(&amp;bytes, filter_type);</code></pre>
<p>Note the referencing sigil in front of <code>bytes</code>.</p>
<p>✅ Write the output to disk</p>
<pre><code class="language-rust">std::fs::write(output, manipulated_image).unwrap();</code></pre>
<hr />
<p>Some ideas on what to do next:</p>
<ul>
<li>Instead of unwrapping all errors, handle <code>Result</code> otherwise</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-a-qt-qml-gui-with-rust"><a class="header" href="#building-a-qt-qml-gui-with-rust">Building a Qt (QML) GUI with Rust</a></h1>
<p>In this tutorial you'll get familiar with:</p>
<ul>
<li>Setting up the Rust build system to link with Qt</li>
<li>Starting a Qt/QML application from Rust</li>
<li>Creating QObjects in Rust and using them in your QML GUI</li>
</ul>
<p>We will create a small GUI that can load an image, apply a filter to it and display the result.</p>
<p>The result will look something like this:</p>
<p><img src="tutorial/qt-gui/qt-gui-skyline.png" alt="A Qt application showing a picture of a Skyline with a lofi filter applied to it" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-a-simple-qt-application-with-rust"><a class="header" href="#building-a-simple-qt-application-with-rust">Building a simple Qt application with Rust</a></h1>
<p>CXX-Qt provides helper libraries that make it easy for the Rust build system to link to Qt.</p>
<p>The goal for now is to create a simple program that just launches an Qt/QML application.</p>
<p>✅ Create a new Rust application</p>
<pre><code class="language-console">cargo new qt-gui
cd qt-gui
</code></pre>
<p>✅ Add a simple QML main file in <code>qml/main.qml</code></p>
<pre><code class="language-qml">import QtQuick 2.15
import QtQuick.Controls 2.15
import QtQuick.Window 2.15

ApplicationWindow {
    height: 480
    title: qsTr(&quot;Hello World&quot;)
    visible: true
    width: 640
}
</code></pre>
<p>✅ Add dependencies to the <code>Cargo.toml</code> file</p>
<pre><code class="language-toml">[dependencies]
rustagram2=&quot;2&quot;
cxx=&quot;1.0.95&quot;
cxx-qt = { git=&quot;https://github.com/LeonMatthesKDAB/cxx-qt&quot;, branch=&quot;qimage&quot; }
cxx-qt-lib = { git=&quot;https://github.com/LeonMatthesKDAB/cxx-qt&quot;, branch=&quot;qimage&quot; }

[build-dependencies]
# The &quot;link_qt_object_files&quot; is required when using Cargo to link to Qt statically.
cxx-qt-build = { git=&quot;https://github.com/LeonMatthesKDAB/cxx-qt&quot;, branch=&quot;qimage&quot;, features = [ &quot;qt_qml&quot;, &quot;link_qt_object_files&quot; ] } 
</code></pre>
<pre><code class="language-diff">- At the time of writing (15.11.2023), CXX-Qt 0.6 hasn't been released yet.
- To keep the training material up-to-date with the new API introduced in version 0.6,
- we'll use the version from Github for now.
- The training material on Github will be updated as soon as version 0.6 is released!

- Do note that the public documentation for CXX-Qt is still for version 0.5.
- You should wait before following this tutorial until version 0.6 is
- released in the coming weeks.
</code></pre>
<details>
<summary> Future imports once CXX-Qt 0.6 is released </summary>
<pre><code class="language-toml">[dependencies]
rustagram2=&quot;2&quot;
cxx=&quot;1.0.95&quot;
cxx-qt=&quot;0.6&quot;
cxx-qt-lib=&quot;0.6&quot;

[build-dependencies]
# The &quot;link_qt_object_files&quot; is required when using Cargo to link to Qt statically.
cxx-qt-build = { version=&quot;0.6&quot;, features = [ &quot;qt_qml&quot;, &quot;link_qt_object_files&quot; ] } 
</code></pre>
</details>
<p>CXX-Qt is split up into multiple crates.</p>
<ul>
<li>CXX-Qt - Allows you to create QObjects from Rust and to interact with existing QObjects</li>
<li>CXX-Qt-lib - Library of bindings to Qt types like <code>QString</code>, <code>QApplication</code>, etc.</li>
<li>CXX-Qt-build - A build-system library to link Rust with Qt, build QML modules, etc.</li>
</ul>
<p>We will also need CXX itself later on, so include that as well.</p>
<p>✅ Next to the <code>Cargo.toml</code> file, add a <code>build.rs</code> file with the following contents:</p>
<pre><code class="language-rust">use cxx_qt_build::{CxxQtBuilder, QmlModule};

fn main() {
    CxxQtBuilder::new()
        // - Qt Core is always linked
        // - Qt Qml is linked by enabling the qt_qml Cargo feature.
        // - Qt Qml requires linking Qt Network on macOS
        .qt_module(&quot;Network&quot;)
        .qt_module(&quot;Quick&quot;)
        .qml_module(QmlModule::&lt;&amp;str, _&gt; {
            uri: &quot;com.kdab.cxx_qt.demo&quot;,
            rust_files: &amp;[],
            qml_files: &amp;[&quot;qml/main.qml&quot;],
            ..Default::default()
        })
        .build();
}</code></pre>
<p>It uses the <code>cxx-qt-build</code> library to:</p>
<ol>
<li>Check that the QtQuick module is available</li>
<li>Create a QML module out of the <code>main.qml</code> file.</li>
<li>Link the QML module and Qt itself to our Rust application.</li>
</ol>
<blockquote>
<p>Troubleshooting: It is important that the <code>build.rs</code> file is
next to the <code>Cargo.toml</code> file at the root of the crate.</p>
<p>It can <strong>NOT</strong> be located in the <code>src/</code> directory.</p>
</blockquote>
<p>✅ Add the startup code to <code>src/main.rs</code></p>
<pre><code class="language-rust">use cxx_qt_lib::{QGuiApplication, QQmlApplicationEngine, QUrl};

fn main() {
    // Create the application and engine
    let mut app = QGuiApplication::new();
    let mut engine = QQmlApplicationEngine::new();

    // Load the QML path into the engine
    if let Some(engine) = engine.as_mut() {
        engine.load(&amp;QUrl::from(&quot;qrc:/qt/qml/com/kdab/cxx_qt/demo/qml/main.qml&quot;));
    }

    // Start the app
    if let Some(app) = app.as_mut() {
        app.exec();
    }
}</code></pre>
<blockquote>
<p>Take a minute to thoroughly read this code and compare it to a typical C++ main
function that launches a Qt application.</p>
<p>❓ What is different? What is similar?<br />
❓ Why are the <code>if let Some(...)</code> expressions necessary?</p>
</blockquote>
<p>✅ Run the application</p>
<pre><code class="language-console">cargo run
</code></pre>
<blockquote>
<p>If <code>qmake</code> is not in your path, remember to tell Cargo where to find it
with the <code>QMAKE</code> environment variable.</p>
<pre><code class="language-console">QMAKE=.../qmake cargo run
</code></pre>
</blockquote>
<p>✅ An empty window appears
<img src="tutorial/qt-gui/./qt-gui-empty-window.png" alt="An empty window with the title &quot;Hello World&quot;" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-the-qml-gui"><a class="header" href="#creating-the-qml-gui">Creating the QML GUI</a></h1>
<p>The goal of this part is to add a QML GUI for our application.
For now, we can leave out loading an actual file.
You can just use a rectangle as a placeholder for now.</p>
<p>In the end it should look similar to this:
<img src="tutorial/qt-gui/./qt-gui-placeholder.png" alt="A GUI application with a large red rectangle, as well as a &quot;Browse...&quot; button and a dropdown menu." /></p>
<p>The red rectangle serves as a placeholder for our filtered image.</p>
<p>✅ Add the control elements to <code>qml/main.qml</code></p>
<p>You can use <a href="https://doc.qt.io/qt-6/qtquickcontrols-index.html">Qt Quick Controls 2</a> for this.
The list of available QML types is listed <a href="https://doc.qt.io/qt-6/qtquick-controls-qmlmodule.html">in the Qt documentation</a>.</p>
<p>The controls should include:</p>
<ul>
<li>✅ A <a href="https://doc.qt.io/qt-6/qml-qtquick-controls-button.html"><code>Button</code></a> to browse files</li>
<li>✅ A <a href="https://doc.qt.io/qt-6/qml-qtquick-controls-label.html"><code>Label</code></a> showing the currently selected file.</li>
<li>✅ A <a href="https://doc.qt.io/qt-6/qml-qtquick-controls-combobox.html"><code>ComboBox</code></a> that should include:</li>
</ul>
<pre><code class="language-qml">&quot;1977&quot;,
&quot;nineteenseventyseven&quot;,
&quot;aden&quot;,
&quot;brannan&quot;,
&quot;brooklyn&quot;,
&quot;clarendon&quot;,
&quot;earlybird&quot;,
&quot;gingham&quot;,
&quot;hudson&quot;,
&quot;inkwell&quot;,
&quot;kelvin&quot;,
&quot;lark&quot;,
&quot;lofi&quot;,
&quot;maven&quot;,
&quot;mayfair&quot;,
&quot;moon&quot;,
&quot;nashville&quot;,
&quot;reyes&quot;,
&quot;rise&quot;,
&quot;slumber&quot;,
&quot;stinson&quot;,
&quot;toaster&quot;,
&quot;valencia&quot;,
&quot;walden&quot;,
</code></pre>
<p>✅ Lay out the Control elements using <a href="https://doc.qt.io/qt-6/qtquicklayouts-index.html">layouts</a></p>
<p>✅ Add a <a href="https://doc.qt.io/qt-6/qml-qtquick-rectangle.html"><code>Rectangle</code></a> as a placeholder for our image converter</p>
<p>✅ Hook up the <code>Browse...</code> button to open a <a href="https://doc.qt.io/qt-6/qml-qtquick-dialogs-filedialog.html"><code>FileDialog</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-qquickpainteditem-in-rust"><a class="header" href="#creating-a-qquickpainteditem-in-rust">Creating a QQuickPaintedItem in Rust</a></h1>
<p>To render a QImage instance in QML there are two simple approaches</p>
<ul>
<li>Subclass <a href="https://doc.qt.io/qt-6/qquickpainteditem.html"><code>QQuickPaintedItem</code></a> and use the <a href="https://doc.qt.io/qt-6/qpainter.html"><code>QPainter</code></a> interface</li>
<li>Provide a custom <a href="https://doc.qt.io/qt-6/qquickimageprovider.html"><code>QQuickImageProvider</code></a>.</li>
</ul>
<p>Because <code>QPainter</code> is very versatile and easy to implement with CXX-Qt, we'll use the first approach for our use-case.</p>
<p>✅ Add a new Rust file for the <code>QQuickPaintedItem</code> subclass (e.g. called <code>image_painter.rs</code>).</p>
<pre><code class="language-console">$ tree -I &quot;target/&quot;
.
├── build.rs
├── Cargo.lock
├── Cargo.toml
├── qml
│   └── main.qml
└── src
    ├── image_painter.rs
    └── main.rs

3 directories, 6 files
</code></pre>
<p>Before you do anything else, make sure to</p>
<p>✅ Register this file with the build system</p>
<p>Because we will be using the <code>#[cxx_qt::bridge]</code> macro, we have to register this file twice.</p>
<ol>
<li>In the <code>src/main.rs</code> file, add a line: <code>pub mod image_painter;</code><br />
This registers the new file as a module of our application and makes it known to Cargo.</li>
<li>In the <code>build.rs</code> file, add the file to the list of rust_files of the QmlModule.<br />
This registers the new file with CXX-Qt.
It tells CXX-Qt to generate a C++ class from it, run moc and link the resulting class into our application.
This is only necessary because we want to use CXX-Qt within the file.
Doing this second step is not necessary for a normal Rust module.</li>
</ol>
<pre><code class="language-rust">use cxx_qt_build::{CxxQtBuilder, QmlModule};

fn main() {
    CxxQtBuilder::new()
        // - Qt Core is always linked
        // - Qt Qml is linked by enabling the qt_qml Cargo feature.
        // - Qt Qml requires linking Qt Network on macOS
        .qt_module(&quot;Network&quot;)
        .qt_module(&quot;Quick&quot;)
        .qml_module(QmlModule {
            uri: &quot;com.kdab.cxx_qt.demo&quot;,
            rust_files: &amp;[&quot;src/image_painter.rs&quot;], // &lt;- Add all files that
            qml_files: &amp;[&quot;qml/main.qml&quot;],          //    include a #[cxx_qt::bridge].
            ..Default::default()
        })
        .build();
}</code></pre>
<blockquote>
<p>It is a common mistake to forget to include CXX-Qt files in the <code>build.rs</code> script.
Make sure to try removing the file from the list so you know what happens in this case.</p>
<p>❓ What error do you get?</p>
</blockquote>
<p>Now we can start adding a new <code>QQuickPaintedItem</code> subclass.</p>
<p>CXX-Qt allows us to create new <code>QObject</code> (and therefore <code>QQuickPaintedItem</code>) subclasses.
These subclasses are defined in C++ and their data layout cannot be changed from Rust directly.
Instead, every subclass generated by CXX-Qt contains an instance of a Rust struct.
It is this Rust struct that therefore defines the data layout used within CXX-Qt objects.</p>
<p>We can create a new QObject class for any Rust struct we like.</p>
<p>✅ Create a new empty Rust struct for our class</p>
<p>The struct should implement the <code>Default</code> trait.
Ideally name the struct <code>ImagePainterRust</code>.</p>
<details>
<summary>Example definition</summary>
<pre><code class="language-rust">#[derive(Default)]
struct ImagePainterRust {}</code></pre>
</details>
<p>Now we can create our <code>QQuickPaintedItem</code> subclass by using a <code>#[cxx_qt::bridge]</code> module.</p>
<p>This bridge module is similar to a header file in C++.
It only includes declarations, not definitions.
Using the bridge we can declare which items exist in C++ and expose them to Rust.
And we can also declare Rust items to be exposed to C++.</p>
<p>The syntax is based on and compatible with CXX.
You can read up on CXX in the <a href="https://cxx.rs">CXX book</a>.</p>
<p>To create our <code>QQuickPaintedItem</code> subclass, we first need to include the appropriate C++ headers,
then declare the types we want to use from Rust.
For our first example, we'll only set the <code>fillColor</code> and not actually paint anything using the <code>QPainter</code>.</p>
<p>✅ Create a new <code>#[cxx_qt::bridge]</code> module</p>
<p>It should include the following declarations/includes:</p>
<ul>
<li>✅ An import of <code>QColor</code> from cxx-qt-lib <a href="https://docs.rs/cxx-qt-lib/latest/cxx_qt_lib/struct.QColor.html">(see the CXX-Qt documentation)</a></li>
<li>✅ An include to the <code>QQuickPaintedItem</code> header</li>
<li>✅ An include for the <code>QPainter</code> header, as well as a declaration of the <code>QPainter</code> type.</li>
</ul>
<pre><code class="language-rust">#[cxx_qt::bridge(cxx_file_stem = &quot;image_painter&quot;)]
pub mod qobject {
    unsafe extern &quot;C++&quot; {
        include!(&quot;cxx-qt-lib/qcolor.h&quot;);
        type QColor = cxx_qt_lib::QColor;

        include!(&lt;QtQuick/QQuickPaintedItem&gt;);
    }

    unsafe extern &quot;C++&quot; {
        include!(&lt;QtGui/QPainter&gt;);
        type QPainter;
    }
}</code></pre>
<blockquote>
<p>Take a look at the <a href="https://cxx.rs">CXX documentation</a> and the <a href="https://docs.rs/cxx-qt-lib/latest/cxx_qt_lib/index.html">CXX-Qt-lib</a> documentation.</p>
<p>❓ Is <code>QColor</code> an opaque or a trivial type? What does this mean when using QColor in Rust?<br />
❓ What's the difference between declaring a <code>type QPainter</code> vs. <code>type QPainter = ...;</code>?<br />
❓ What's the difference between <code>unsafe extern &quot;C++&quot;</code> and <code>extern &quot;C++&quot;</code>?<br />
❓ (advanced) Why is the <code>include!(&quot;cxx-qt-lib/qcolor.h&quot;);</code> necessary?</p>
</blockquote>
<p>Now that we have our types ready to go, we can declare our new <code>QQuickPaintedItem</code> subclass.</p>
<p>With CXX-Qt this means following these steps:</p>
<ul>
<li>✅ Create a new QObject subclass using <code>type X = super::Y;</code> with the <code>#[qobject]</code> attribute
<ul>
<li>This tells CXX-Qt to create a new QObject subclass of the name <code>X</code>.
This class will contain an instance of the <code>super::Y</code> Rust struct which contains the actual data (nothing for now).</li>
</ul>
</li>
<li>✅ Tell CXX-Qt to use <code>QQuickPaintedItem</code> as our base class using <code>#[base=&quot;...&quot;]</code></li>
<li>✅ Declare the necessary functions
<ul>
<li>✅ Tell Rust that <code>setFillColor</code> is inherited from <code>QQuickPaintedItem</code></li>
<li>✅ Declare that <code>paint</code> should override the base class implementation and is implemented in Rust.</li>
</ul>
</li>
<li>✅ Tell CXX-Qt that we want a default-constructor for <code>ImagePainter</code>.
<ul>
<li>We'll implement this constructor later in Rust.</li>
</ul>
</li>
</ul>
<blockquote>
<p>Whilst we won't be using the <code>paint</code> function right now, we still need to implement it as it is a pure virtual function.</p>
<p>If you forget to implement this function, you may get an error like this:</p>
<pre><code>ImagePainter is neither a QObject, nor default- and copy-constructible, nor uncreatable. You should not use it as a QML type.
QQmlApplicationEngine failed to load component
qrc:/qt/qml/com/kdab/cxx_qt/demo/qml/main.qml:75:9: Element is not creatable.
</code></pre>
</blockquote>
<pre><code class="language-rust">#[cxx_qt::bridge(cxx_file_stem = &quot;image_painter&quot;)]
pub mod qobject {
    // ...

    unsafe extern &quot;RustQt&quot; {
        #[qml_element]
        #[base = &quot;QQuickPaintedItem&quot;]
        #[qobject]
        type ImagePainter = super::ImagePainterRust;

        #[inherit]
        #[rust_name = &quot;set_fill_color&quot;]
        fn setFillColor(self: Pin&lt;&amp;mut ImagePainter&gt;, color: &amp;QColor);

        #[cxx_override]
        unsafe fn paint(self: Pin&lt;&amp;mut ImagePainter&gt;, painter: *mut QPainter);
    }

    impl cxx_qt::Constructor&lt;()&gt; for ImagePainter {}
}</code></pre>
<blockquote>
<p>Some food for thought:</p>
<p>❓ What does the <code>#[qml_element]</code> attribute do?<br />
❓ Why does <code>paint</code> need to be marked <code>unsafe</code>? What happens without it?<br />
❓ Is the <code>cxx_qt::Constructor</code> declaration always needed? Why is it necessary in this case?</p>
<p>Try figuring this out using the <a href="https://cxx.rs">CXX</a> and the <a href="https://kdab.github.io/cxx-qt/book/">CXX-Qt books</a>.</p>
</blockquote>
<p>Now that we've written our declarations we still need implementations for:</p>
<ul>
<li>✅ The <code>paint</code> function</li>
<li>✅ The default constructor</li>
</ul>
<p>Remember that our CXX-Qt bridge only includes declarations.
So any definitions go <strong>outside</strong> the bridge.</p>
<pre><code class="language-rust">#[cxx_qt::bridge(cxx_file_stem = &quot;image_painter&quot;)]
pub mod qobject {
    // ...
}

impl cxx_qt::Initialize for qobject::ImagePainter {
    fn initialize(mut self: Pin&lt;&amp;mut Self&gt;) {
        self.as_mut().set_fill_color(&amp;QColor::from_rgb(0, 119, 200));
    }
}

impl qobject::ImagePainter {
    fn paint(self: Pin&lt;&amp;mut Self&gt;, _painter: *mut qobject::QPainter) {
        // Do nothing (yet)
    }
}</code></pre>
<blockquote>
<p>Note that the constructor is implemented using the <code>cxx_qt::Initialize</code> trait
instead of the more complex <code>cxx_qt::Constructor&lt;()&gt;</code> trait.</p>
<p>✅ (optional) If you feel up to it, try to replace the <code>impl cxx_qt::Initialize</code>
with a full <code>impl cxx_qt::Constructor</code> implementation.</p>
</blockquote>
<p>Now our type should be ready for a first test in our QML GUI.</p>
<p>✅ Replace the placeholder rectangle with an <code>ImagePainter</code> instance in <code>qml/main.qml</code>.</p>
<p>It should now display a more pleasant blue.</p>
<p><img src="tutorial/qt-gui/./qquickpainteditem.png" alt="Our previous Qt GUI with our blue ImagePainter instead of the previous red rectangle" /></p>
<p>If you're having trouble, check out the <a href="https://github.com/ferrous-systems/qt-training-2023/tree/main/crates/qt-gui-qquickpainteditem">full example code</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-behavior-in-rust"><a class="header" href="#adding-behavior-in-rust">Adding behavior in Rust</a></h1>
<p>At the moment our ImagePainter doesn't do anything, not even paint an image.</p>
<p>So let's add some behavior.
We want our ImagePainter to load a file from a given path, display a status for errors, etc.</p>
<p>✅ First, add the necessary fields to the <code>ImagePainterRust</code> struct</p>
<ul>
<li>✅ The image path to load from</li>
<li>✅ Current status</li>
<li>✅ The converted image</li>
<li>✅ A boolean to indicate whether the conversion is currently running</li>
<li>✅ The filter to use for conversion</li>
</ul>
<p>✅ Then make sure to initialize the values to sensible definitions by adding a custom implementation of the <a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code> trait</a>.</p>
<p>✅ And don't forget to import the new types with <code>use</code>.</p>
<details>
<summary>Example definition</summary>
<pre><code class="language-rust">use cxx_qt_lib::{QColor, QImage, QString, QUrl};

pub struct ImagePainterRust {
    filter: QString,
    status: QString,
    running: bool,
    file_url: QUrl,

    image: Option&lt;QImage&gt;,
}

impl Default for ImagePainterRust {
    fn default() -&gt; Self {
        Self {
            filter: QString::from(&quot;1977&quot;),
            status: QString::from(&quot;No file selected&quot;),
            image: None,
            file_url: QUrl::default(),
            running: false,
        }
    }
}</code></pre>
</details>
<p>Now that we've added members to the Rust side, let's expose them as <code>Q_PROPERTY</code>s.
To do so, add <code>#[qproperty([TYPE], [FIELD_NAME])]</code> attributes to the <code>#[qobject]</code> type declaration for every property.</p>
<p>Note that the image itself won't be a property as QML unfortunately can't easily render <code>QImage</code> instances.
We'll use the <code>QPainter</code> for this.</p>
<p>✅ Add properties for <code>status</code>, <code>filter</code>, <code>running</code> and <code>file_url</code>.</p>
<p>✅ Add the imports for the necessary types (<code>QString</code>, <code>QUrl</code>) to the <code>#[cxx_qt::bridge]</code>.</p>
<details>
<summary>Example definition</summary>
<pre><code class="language-rust">#[cxx_qt::bridge(cxx_file_stem = &quot;image_painter&quot;)]
pub mod qobject {
    unsafe extern &quot;C++&quot; {
        include!(&quot;cxx-qt-lib/qcolor.h&quot;);
        type QColor = cxx_qt_lib::QColor;

        include!(&quot;cxx-qt-lib/qurl.h&quot;);
        type QUrl = cxx_qt_lib::QUrl;

        include!(&quot;cxx-qt-lib/qstring.h&quot;);
        type QString = cxx_qt_lib::QString;

        include!(&lt;QtQuick/QQuickPaintedItem&gt;);
    }

    // ...

    unsafe extern &quot;RustQt&quot; {
        #[qml_element]
        #[base = &quot;QQuickPaintedItem&quot;]
        #[qobject]
        #[qproperty(QString, status)]
        #[qproperty(QString, filter)]
        #[qproperty(QUrl, file_url)]
        #[qproperty(bool, running)]
        type ImagePainter = super::ImagePainterRust;

        // ...
    }

    // ...
}</code></pre>
</details>
<p>✅ Check the new properties work by hooking them up to QML.</p>
<p>They don't do anything yet, but you also shouldn't get any errors from QML.</p>
<p>✅ Create a new function on our <code>ImagePainter</code> that will later get called whenever we need to update the image:</p>
<pre><code class="language-rust">impl qobject::ImagePainter {
    fn load_file(mut self: Pin&lt;&amp;mut Self&gt;) {
        println!(&quot;Hello world from CXX-Qt&quot;);
    }
}</code></pre>
<p>✅ Hook up the function so it is called whenever the filter or the file path change</p>
<pre><code class="language-rust">impl cxx_qt::Initialize for qobject::ImagePainter {
    fn initialize(mut self: Pin&lt;&amp;mut Self&gt;) {
        self.as_mut().set_fill_color(&amp;QColor::from_rgb(0, 119, 200));

        self.as_mut().on_filter_changed(Self::load_file).release();

        self.as_mut().on_file_url_changed(Self::load_file).release();
    }
}</code></pre>
<blockquote>
<p>Try finding explanations for these answers in the <a href="https://docs.rs/cxx-qt-lib/latest/cxx_qt_lib/">CXX-Qt book</a>.</p>
<p>❓ Why is the <code>release()</code> call necessary after connecting to a signal?<br />
❓ How can you change the <a href="https://doc.qt.io/qt-6/qt.html#ConnectionType-enum">connection type</a> when connecting to a signal from Rust?</p>
</blockquote>
<p>✅ Check that you can successfully print &quot;Hello world from CXX-Qt!&quot; by selecting a file path or changing the image filter</p>
<p>Before we implement the image loading and filtering, we'll need some additional types:</p>
<ul>
<li>QByteArray (and the QByteArrayCursor helper)</li>
<li>QSizeF and QRectF to calculate the size for painting</li>
</ul>
<p>✅ Import these types from cxx-qt-lib</p>
<p>✅ Add QSizeF and QRectF to the <code>#[cxx_qt::bridge]</code></p>
<p>We'll also need a few more functions from C++ to paint the image, get the size of the ImagePainter, etc.</p>
<p>✅ Add declarations for the following functions to the <code>#[cxx_qt::bridge]</code></p>
<ul>
<li>✅ <a href="https://doc.qt.io/qt-5/qpainter.html#drawImage-4">QPainter::drawImage</a></li>
<li>✅ <a href="https://doc.qt.io/qt-6/qquickpainteditem-members.html">QQuickPaintedItem::size</a></li>
<li>✅ <a href="https://doc.qt.io/qt-6/qquickpainteditem-members.html">QQuickPaintedItem::update</a></li>
</ul>
<p>✅ Tell CXX-Qt to enable threading support by means of the <code>cxx_qt::Threading</code> trait</p>
<details>
<summary> Example declarations </summary>
<pre><code class="language-rust">#[cxx_qt::bridge(cxx_file_stem = &quot;image_painter&quot;)]
mod qobject {
    // ...

    unsafe extern &quot;C++&quot; {
        include!(&lt;QtGui/QPainter&gt;);
        type QPainter;

        #[rust_name = &quot;draw_image&quot;]
        fn drawImage(self: Pin&lt;&amp;mut QPainter&gt;, rectangle: &amp;QRectF, image: &amp;QImage);
    }

    unsafe extern &quot;RustQt&quot; {
        // ...

        #[inherit]
        fn size(self: &amp;ImagePainter) -&gt; QSizeF;

        #[inherit]
        fn update(self: Pin&lt;&amp;mut ImagePainter&gt;);
    }

    impl cxx_qt::Threading for ImagePainter {}
    // ...
}</code></pre>
</details>
<p>✅ Add code to load the selected image from disk and display it in the <code>update</code> function</p>
<p>Documentation that may be useful:</p>
<ul>
<li><a href="https://docs.rs/cxx-qt-lib/latest/cxx_qt_lib/">CXX-Qt-lib</a> for using Qt types from Rust</li>
<li><a href="https://docs.rs/rustagram2/latest/rustagram/">rustagram2</a>
<ul>
<li>Click on the Re-export of the <code>image</code> crate to learn more about how to use the resulting image.</li>
</ul>
</li>
<li><a href="https://doc.rust-lang.org/std/index.html">Rust standard library documentation</a></li>
</ul>
<p>✅ Add threading in Rust via <a href="https://doc.rust-lang.org/std/thread/fn.spawn.html"><code>std::thread::spawn</code></a> to load and convert the image in the background</p>
<ul>
<li>Check out the <a href="https://docs.rs/cxx-qt-lib/latest/cxx_qt_lib/">CXX-Qt book</a> to learn more about Threading</li>
</ul>
<p>✅ Add a <code>BusyIndicator</code> to QML to show that the background thread is wthat the background thread is waiting.</p>
<p>The resulting application should look like this:</p>
<p><img src="tutorial/qt-gui/./qt-gui-skyline.png" alt="The final application, showing the picture of a skyline that has been filtered using the &quot;lofi&quot; filter" /></p>
<p>✅ Check out the <a href="https://github.com/ferrous-systems/qt-training-2023/tree/main/crates/qt-gui">full example code</a> and compare it with your implementation</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references"><a class="header" href="#references">References</a></h1>
<ul>
<li><a href="https://github.com/ferrous-systems/rust-training">The Ferrous Systems main training material</a></li>
<li><a href="https://kdab.github.io/cxx-qt/book/">The CXX-Qt book</a>
<ul>
<li><a href="https://docs.rs/cxx-qt/latest/cxx_qt/">CXX-Qt reference</a></li>
<li><a href="https://docs.rs/cxx-qt-lib/latest/cxx_qt_lib/">CXX-Qt-lib reference</a></li>
<li><a href="https://docs.rs/cxx-qt-build/latest/cxx_qt_build/">CXX-Qt-build reference</a></li>
</ul>
</li>
<li><a href="https://cxx.rs/">The CXX book</a></li>
<li><a href="https://doc.rust-lang.org/book/">The Rust book</a>
<ul>
<li><a href="https://doc.rust-lang.org/std/index.html">Rust standard library reference</a></li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
